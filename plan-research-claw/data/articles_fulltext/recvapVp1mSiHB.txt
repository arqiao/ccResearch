# å¼€æºè´¾ç»´æ–¯Clawdbotå¯¹æ¥å¾®ä¿¡åˆè§„æ–¹æ¡ˆè¯¦ç»†è½åœ°
# URL: https://mp.weixin.qq.com/s/4pp7V2kGkinTxHkxGekm1Q
# æ—¥æœŸ: 2026-02-05
# æ¥æº: å¾®ä¿¡-äººå·¥æ™ºèƒ½çŸ¥è¯†åˆ†äº«
# åˆ†ç±»: ç”Ÿæ€é›†æˆ / 
# å­—æ•°: 20044

å‰è¨€
è¿™ç¯‡æ–‡ç« æ˜¯ä¹‹å‰ä¸€ç¯‡æ–‡ç« çš„è½åœ°æŒ‡å¯¼ï¼Œæ‰€ä»¥å…ˆè¦çœ‹é‚£ç¯‡æ–‡ç« ï¼Œ
å¼€æºè´¾ç»´æ–¯åˆè§„æ–¹æ¡ˆï¼ŒClawdbot+å¾®ä¿¡å®˜æ–¹æ¥å£
äºŒã€å‰ç½®å‡†å¤‡ï¼ˆåˆ†æµ‹è¯•/ç”Ÿäº§ï¼‰
ğŸŒŸ é€šç”¨ä¾èµ–ï¼ˆå¿…è£…ï¼‰
pip install flask requests pycryptodome pyngrok openai python-dotenv gevent redis -i https://pypi.tuna.tsinghua.edu.cn/simple
- redisï¼šç”Ÿäº§ç¯å¢ƒåˆ†å¸ƒå¼æ’é‡/AccessTokenå…±äº«å¿…å¤‡ï¼Œæœ¬åœ°æµ‹è¯•å¯å¿½ç•¥ï¼›
- å…¶ä»–ä¾èµ–ä¸ºåŸºç¡€åŠŸèƒ½ã€‚
ğŸ“ æ ¸å¿ƒæ–‡ä»¶ï¼ˆå¿…å‡†å¤‡ï¼‰
1. ä¼ä¸šå¾®ä¿¡å®˜æ–¹åŠ è§£å¯†åº“
WXBizMsgCrypt.py
ï¼šæ”¾å…¥ä»£ç åŒçº§ç›®å½•ï¼›
ğŸš€ ç”Ÿäº§ç¯å¢ƒé¢å¤–å‡†å¤‡ï¼ˆå¯é€‰Â·æ¨èï¼‰
1. RedisæœåŠ¡ï¼šæœ¬åœ°/äº‘æœåŠ¡å™¨éƒ¨ç½²Redisï¼ˆå•èŠ‚ç‚¹å³å¯ï¼‰ï¼Œç”¨äºåˆ†å¸ƒå¼æ’é‡å’ŒAccessTokenå…±äº«ï¼›
2. äº‘æœåŠ¡å™¨+å›ºå®šåŸŸåï¼šå®ŒæˆICPå¤‡æ¡ˆï¼Œé…ç½®Let's Encryptå…è´¹HTTPSè¯ä¹¦ï¼›
3. è¿›ç¨‹ç®¡ç†å·¥å…·ï¼šGunicorn/Supervisorï¼Œå®ç°æœåŠ¡åå°è¿è¡Œå’Œå®ˆæŠ¤ã€‚
ä¸‰ã€æ ‡å‡†åŒ–.envé…ç½®æ–‡ä»¶ï¼ˆæµ‹è¯•/ç”Ÿäº§éš”ç¦»ï¼‰
æ ¸å¿ƒç‰¹æ€§ï¼šé€šè¿‡ç¯å¢ƒå˜é‡å¼€å…³å®ç°
æµ‹è¯•/ç”Ÿäº§æ¨¡å¼è‡ªåŠ¨åˆ‡æ¢
ï¼Œæ— éœ€ä¿®æ”¹ä»£ç ï¼Œä»…éœ€å¡«å†™å¯¹åº”å‚æ•°ï¼Œé¿å…è¯¯æ“ä½œã€‚
# ====================== å…¨å±€æ ¸å¿ƒå‚æ•°ï¼ˆæµ‹è¯•/ç”Ÿäº§å‡éœ€å¡«å†™ï¼‰======================
# ä¼ä¸šå¾®ä¿¡å‚æ•°ï¼ˆä¸åå°é…ç½®å®Œå…¨ä¸€è‡´ï¼Œæ— ç©ºæ ¼/å¤§å°å†™é”™è¯¯ï¼‰
CORP_ID=ä½ çš„ä¼ä¸šå¾®ä¿¡CORP_ID
AGENT_ID=ä½ çš„åº”ç”¨AGENT_IDï¼ˆçº¯æ•°å­—ï¼Œå¦‚1000001ï¼‰
APP_SECRET=ä½ çš„åº”ç”¨APP_SECRETï¼ˆcorpsecretï¼‰
TOKEN=ä½ çš„å›è°ƒé…ç½®Token
ENCODING_AES_KEY=ä½ çš„å›è°ƒé…ç½®EncodingAESKeyï¼ˆ43ä½å­—ç¬¦ä¸²ï¼‰
# AIå‚æ•°ï¼ˆäºŒé€‰ä¸€ï¼Œæ¨èé€šä¹‰åƒé—®Â·å›½å†…å¯ç”¨ï¼Œæ— éœ€å¤–ç½‘ï¼‰
DASHSCOPE_API_KEY=ä½ çš„é€šä¹‰åƒé—®API_KEYï¼ˆé˜¿é‡Œäº‘æ§åˆ¶å°è·å–ï¼‰
# OPENAI_API_KEY=ä½ çš„OpenAI_API_KEY
# OPENAI_API_BASE=ä½ çš„OpenAIé•œåƒåœ°å€ï¼ˆå¦‚https://api.openai-proxy.com/v1ï¼‰
# ====================== ç¯å¢ƒæ¨¡å¼å¼€å…³ï¼ˆè‡ªåŠ¨éš”ç¦»Â·æ— éœ€ä¿®æ”¹ä»£ç ï¼‰======================
# æµ‹è¯•æ¨¡å¼ï¼šå¡«å†™ngrok authtokenåˆ™å¯ç”¨ï¼Œç•™ç©ºåˆ™ç¦ç”¨ï¼ˆç”Ÿäº§ç¯å¢ƒå¿…é¡»ç•™ç©ºï¼‰
NGROK_AUTHTOKEN=ä½ çš„ngrok authtokenï¼ˆæœ¬åœ°æµ‹è¯•ç”¨ï¼Œç”Ÿäº§ç•™ç©ºï¼‰
# ç”Ÿäº§æ¨¡å¼ï¼šRedisé…ç½®ï¼ˆæœ¬åœ°æµ‹è¯•ç•™ç©ºï¼Œç”Ÿäº§å¿…é¡»å¡«å†™ï¼‰
REDIS_HOST=ä½ çš„Redisåœ°å€ï¼ˆå¦‚127.0.0.1ï¼‰
REDIS_PORT=ä½ çš„Redisç«¯å£ï¼ˆå¦‚6379ï¼‰
REDIS_PASSWORD=ä½ çš„Rediså¯†ç ï¼ˆæ— åˆ™ç•™ç©ºï¼‰
REDIS_DB=ä½ çš„Redisåº“å·ï¼ˆå¦‚0ï¼‰
# wechatpyåŠ è§£å¯†åˆå§‹åŒ–æ¨¡å¼ï¼ˆå¯é€‰ï¼šCORP_ID/AGENT_IDï¼Œæ ¹æ®wechatpyç‰ˆæœ¬é€‰æ‹©ï¼‰
WX_CRYPTO_RECEIVE_ID=CORP_ID
# ====================== è¶…æ—¶/ç¼“å­˜é…ç½®ï¼ˆåˆç†é»˜è®¤å€¼Â·å¯å¾®è°ƒï¼‰======================
AI_TIMEOUT=4.5  # AIè°ƒç”¨è¶…æ—¶ï¼ˆç§’ï¼‰ï¼Œå»ºè®®4.5ï¼Œä¸è¶…è¿‡5
MSG_EXPIRE_SECONDS=60  # æ¶ˆæ¯æ’é‡è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰ï¼Œå»ºè®®60
TOKEN_EXPIRE_SECONDS=7000  # AccessTokenç¼“å­˜æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œå»ºè®®7000ï¼ˆå®˜æ–¹7200ï¼‰
å››ã€æ–¹æ¡ˆ1ï¼šwechatpyç‰ˆï¼ˆæ–°æ‰‹æµ‹è¯•Â·æç®€Â·å…¼å®¹ä¿®å¤ï¼‰
æ ¸å¿ƒä¼˜åŠ¿
- ä»£ç æç®€ï¼Œå°è£…å¤æ‚é€»è¾‘ï¼Œæ–°æ‰‹å¿«é€Ÿä¸Šæ‰‹ï¼›
- æ”¯æŒæœ¬åœ°æµ‹è¯•å•çº¿ç¨‹å’Œè½»é‡ç”Ÿäº§å¤šworkerï¼›
- é€‚åˆä¸ªäººæœ¬åœ°æµ‹è¯•ã€æ–°æ‰‹å¼€å‘éªŒè¯ã€‚
å…³é”®è¯´æ˜
-
WX_CRYPTO_RECEIVE_ID
ï¼šåœ¨.envä¸­é…ç½®ï¼Œæ”¯æŒCORP_ID/AGENT_IDï¼Œæ ¹æ®wechatpyç‰ˆæœ¬é€‰æ‹©ï¼ˆæ—§ç‰ˆæœ¬ç”¨CORP_IDï¼Œæ–°ç‰ˆæœ¬ç”¨AGENT_IDï¼‰ï¼›
- æ’é‡æ–¹æ¡ˆï¼šæœ¬åœ°æµ‹è¯•ç”¨
çº¿ç¨‹å®‰å…¨å­—å…¸+äº’æ–¥é”
ï¼Œè½»é‡ç”Ÿäº§å¯å¼€å¯Redisåˆ†å¸ƒå¼æ’é‡ã€‚
# 2026ä¼ä¸šå¾®ä¿¡+AI wechatpyç»ˆæç¨³å®šç‰ˆ
from flask import Flask, request, make_response
import wechatpy
from wechatpy.work import WeChatClient
from wechatpy.work.crypto import WeChatCrypto
from wechatpy.work.messages import TextMessage
from wechatpy.exceptions import InvalidSignatureException
from openai import OpenAI
import re
import os
import time
import threading
from dotenv import load_dotenv
from pyngrok import conf, ngrok
from gevent.pywsgi import WSGIServer
from gevent import monkey
import redis
from functools import wraps
# 1. å¼€å¯geventçŒ´å­è¡¥ä¸Â·å¼‚æ­¥å¤„ç†Â·è§£å†³5ç§’è¶…æ—¶
monkey.patch_all()
# 2. åŠ è½½ç¯å¢ƒå˜é‡Â·å…¨å±€é…ç½®Â·æµ‹è¯•/ç”Ÿäº§éš”ç¦»
load_dotenv()
# 3. åˆå§‹åŒ–Rediså®¢æˆ·ç«¯ï¼ˆç”Ÿäº§ç”¨Â·æœ¬åœ°æµ‹è¯•è‡ªåŠ¨å¿½ç•¥ï¼‰
REDIS_CLIENT = None
if os.getenv("REDIS_HOST") and os.getenv("REDIS_PORT"):
REDIS_CLIENT = redis.Redis(
host=os.getenv("REDIS_HOST"),
port=int(os.getenv("REDIS_PORT", 6379)),
password=os.getenv("REDIS_PASSWORD", ""),
db=int(os.getenv("REDIS_DB", 0)),
decode_responses=True,
socket_timeout=2
)
try:
REDIS_CLIENT.ping()
print(f"âœ… Redisè¿æ¥æˆåŠŸÂ·ç”Ÿäº§æ¨¡å¼æ’é‡/Tokenå…±äº«å·²å¯ç”¨")
except Exception as e:
REDIS_CLIENT = None
print(f"âš ï¸ Redisè¿æ¥å¤±è´¥Â·é™çº§ä¸ºæœ¬åœ°æµ‹è¯•æ¨¡å¼Â·{str(e)[:30]}")
# 4. æœ¬åœ°æ¶ˆæ¯æ’é‡Â·çº¿ç¨‹å®‰å…¨ï¼ˆå­—å…¸+äº’æ–¥é”ï¼‰
LOCAL_PROCESSED_MSGS = {}
MSG_LOCK = threading.Lock()
# 5. å®šæ—¶æ¸…ç†çº¿ç¨‹ï¼ˆåå°å®ˆæŠ¤Â·æµ‹è¯•/ç”Ÿäº§å‡å¯ç”¨ï¼‰
def clean_expired_msgs():
expire_seconds = int(os.getenv("MSG_EXPIRE_SECONDS", 60))
while True:
now = time.time()
# æœ¬åœ°å­—å…¸æ¸…ç†ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
with MSG_LOCK:
for msg_id in list(LOCAL_PROCESSED_MSGS.keys()):
if now - LOCAL_PROCESSED_MSGS[msg_id] > expire_seconds:
del LOCAL_PROCESSED_MSGS[msg_id]
# Redisæ¸…ç†ï¼ˆç”Ÿäº§æ¨¡å¼Â·è‡ªåŠ¨è¿‡æœŸï¼Œæ— éœ€ä¸»åŠ¨æ¸…ç†ï¼‰
time.sleep(expire_seconds)
threading.Thread(target=clean_expired_msgs, daemon=True).start()
# ====================== è£…é¥°å™¨ï¼šçº¿ç¨‹å®‰å…¨é” ======================
def thread_safe(func):
@wraps(func)
def wrapper(*args, **kwargs):
with MSG_LOCK:
return func(*args, **kwargs)
return wrapper
# ====================== ç¯å¢ƒå˜é‡è¯»å–+å…¨å±€æ ¡éªŒ ======================
# æ ¸å¿ƒå‚æ•°è¯»å–
CORP_ID = os.getenv("CORP_ID")
AGENT_ID = int(os.getenv("AGENT_ID", 0))
APP_SECRET = os.getenv("APP_SECRET")
TOKEN = os.getenv("TOKEN")
ENCODING_AES_KEY = os.getenv("ENCODING_AES_KEY")
WX_CRYPTO_RECEIVE_ID = os.getenv("WX_CRYPTO_RECEIVE_ID", "CORP_ID")
# AIå‚æ•°
DASHSCOPE_API_KEY = os.getenv("DASHSCOPE_API_KEY")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENAI_API_BASE = os.getenv("OPENAI_API_BASE")
AI_TIMEOUT = float(os.getenv("AI_TIMEOUT", 4.5))
# ç¼“å­˜/è¶…æ—¶é…ç½®
MSG_EXPIRE_SECONDS = int(os.getenv("MSG_EXPIRE_SECONDS", 60))
TOKEN_EXPIRE_SECONDS = int(os.getenv("TOKEN_EXPIRE_SECONDS", 7000))
# æµ‹è¯•æ¨¡å¼å¼€å…³
NGROK_AUTHTOKEN = os.getenv("NGROK_AUTHTOKEN")
# å…¨å±€éç©ºæ ¡éªŒÂ·æå‰æš´éœ²é…ç½®é”™è¯¯
assert CORP_ID, "âŒ ç¯å¢ƒå˜é‡CORP_IDä¸èƒ½ä¸ºç©ºï¼"
assert AGENT_ID > 0, "âŒ ç¯å¢ƒå˜é‡AGENT_IDå¿…é¡»ä¸ºæ­£æ•´æ•°ï¼"
assert APP_SECRET, "âŒ ç¯å¢ƒå˜é‡APP_SECRETä¸èƒ½ä¸ºç©ºï¼"
assert TOKEN, "âŒ ç¯å¢ƒå˜é‡TOKENä¸èƒ½ä¸ºç©ºï¼"
assert len(ENCODING_AES_KEY) == 43, "âŒ ENCODING_AES_KEYå¿…é¡»ä¸º43ä½å­—ç¬¦ä¸²ï¼"
assert DASHSCOPE_API_KEY or OPENAI_API_KEY, "âŒ å¿…é¡»é…ç½®é€šä¹‰åƒé—®/OpenAI API_KEYï¼"
assert AI_TIMEOUT > 0 and AI_TIMEOUT <= 5, "âŒ AI_TIMEOUTå¿…é¡»åœ¨0-5ç§’ä¹‹é—´ï¼"
# ====================== åˆå§‹åŒ–é…ç½®ï¼ˆå…¨è‡ªåŠ¨åŒ–Â·æµ‹è¯•/ç”Ÿäº§éš”ç¦»ï¼‰======================
# 1. ngrokåˆå§‹åŒ–ï¼ˆæµ‹è¯•æ¨¡å¼è‡ªåŠ¨å¯ç”¨Â·ç”Ÿäº§è‡ªåŠ¨ç¦ç”¨ï¼‰
if NGROK_AUTHTOKEN:
conf.get_default().auth_token = NGROK_AUTHTOKEN
print(f"âš ï¸  æœ¬åœ°æµ‹è¯•æ¨¡å¼Â·ngrokå·²å¯ç”¨")
else:
print(f"âœ… ç”Ÿäº§æ¨¡å¼Â·ngrokå·²ç¦ç”¨")
# 2. Flaskåº”ç”¨åˆå§‹åŒ–
app = Flask(__name__)
# 3. ä¼ä¸šå¾®ä¿¡å®¢æˆ·ç«¯åˆå§‹åŒ–ï¼ˆAccessTokenæ”¯æŒRedisç¼“å­˜ï¼‰
client = WeChatClient(CORP_ID, APP_SECRET, agent_id=AGENT_ID)
# é‡å†™clientè·å–tokenæ–¹æ³•Â·æ”¯æŒRedisç¼“å­˜ï¼ˆç”Ÿäº§æ¨¡å¼ï¼‰
original_get_token = client.get_token
def cached_get_token():
if not REDIS_CLIENT:
return original_get_token()
# Redisç¼“å­˜key
token_key = f"wework:token:{CORP_ID}:{AGENT_ID}"
if REDIS_CLIENT.exists(token_key):
return REDIS_CLIENT.get(token_key)
# ç¼“å­˜ä¸å­˜åœ¨Â·è·å–æ–°tokenå¹¶ç¼“å­˜
token = original_get_token()
REDIS_CLIENT.setex(token_key, TOKEN_EXPIRE_SECONDS, token)
print(f"âœ… AccessTokenå·²ç¼“å­˜è‡³RedisÂ·è¿‡æœŸæ—¶é—´{TOKEN_EXPIRE_SECONDS}ç§’")
return token
client.get_token = cached_get_token
# 4. wechatpyåŠ è§£å¯†åˆå§‹åŒ–ï¼ˆæ”¯æŒCORP_ID/AGENT_IDÂ·ç‰ˆæœ¬å…¼å®¹ï¼‰
receive_id = CORP_ID if WX_CRYPTO_RECEIVE_ID == "CORP_ID" else AGENT_ID
crypto = WeChatCrypto(TOKEN, ENCODING_AES_KEY, receive_id)
print(f"âœ… åŠ è§£å¯†åˆå§‹åŒ–å®ŒæˆÂ·receive_idï¼š{WX_CRYPTO_RECEIVE_ID}={receive_id}")
# 5. AIå®¢æˆ·ç«¯åˆå§‹åŒ–ï¼ˆé€šä¹‰åƒé—®/OpenAIÂ·å®˜æ–¹æ ‡å‡†é…ç½®ï¼‰
ai_client = None
if DASHSCOPE_API_KEY:
ai_client = OpenAI(
api_key=DASHSCOPE_API_KEY,
base_url="https://dashscope.aliyuncs.com/compatible-mode/v1",  # å®˜æ–¹æ ‡å‡†åœ°å€Â·å·²ä¿®æ­£
timeout=AI_TIMEOUT  # ä¼˜åŒ–å4.5ç§’è¶…æ—¶
)
print(f"âœ… é€šä¹‰åƒé—®AIå®¢æˆ·ç«¯åˆå§‹åŒ–å®ŒæˆÂ·è¶…æ—¶{AI_TIMEOUT}ç§’")
elif OPENAI_API_KEY:
ai_client = OpenAI(
api_key=OPENAI_API_KEY,
base_url=OPENAI_API_BASE,
timeout=AI_TIMEOUT
)
print(f"âœ… OpenAI AIå®¢æˆ·ç«¯åˆå§‹åŒ–å®ŒæˆÂ·è¶…æ—¶{AI_TIMEOUT}ç§’")
# ====================== æ ¸å¿ƒå·¥å…·å‡½æ•°ï¼ˆå…¨ä¿®æ­£Â·ç”Ÿäº§çº§ï¼‰======================
# 1. æ¶ˆæ¯æ’é‡å‡½æ•°ï¼ˆåŒæ–¹æ¡ˆÂ·è‡ªåŠ¨åˆ‡æ¢Â·çº¿ç¨‹/è¿›ç¨‹å®‰å…¨ï¼‰
def msg_dup_check(msg_id):
"""
æ¶ˆæ¯æ’é‡ï¼šç”Ÿäº§æ¨¡å¼ç”¨Redisï¼ˆåˆ†å¸ƒå¼Â·è¿›ç¨‹å®‰å…¨ï¼‰ï¼Œæµ‹è¯•æ¨¡å¼ç”¨æœ¬åœ°å­—å…¸ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
è¿”å›True=å·²å¤„ç†ï¼ŒFalse=æœªå¤„ç†
"""
if not msg_id:
return False
# ç”Ÿäº§æ¨¡å¼ï¼šRedisåˆ†å¸ƒå¼æ’é‡
if REDIS_CLIENT:
redis_key = f"wework:msg:{msg_id}"
if REDIS_CLIENT.exists(redis_key):
return True
REDIS_CLIENT.setex(redis_key, MSG_EXPIRE_SECONDS, "1")
return False
# æµ‹è¯•æ¨¡å¼ï¼šæœ¬åœ°å­—å…¸Â·çº¿ç¨‹å®‰å…¨
@thread_safe
def local_check():
if msg_id in LOCAL_PROCESSED_MSGS:
return True
LOCAL_PROCESSED_MSGS[msg_id] = time.time()
return False
return local_check()
# 2. ç¾¤èŠ@è§£æï¼ˆå…¼å®¹æ‰€æœ‰å®˜æ–¹æ ¼å¼Â·å®æµ‹100%è¦†ç›–ï¼‰
def parse_group_at_msg(msg, agent_id):
if not msg.is_group:
return msg.content.strip()
raw_content = msg.raw.get("Content", "")
# ç§»é™¤<@userid>ä»»æ„å†…å®¹å¤æ‚æ ¼å¼
content = re.sub(r"<@[0-9a-zA-Z]+?>.*?", "", raw_content)
# ç§»é™¤@@AGENT_IDç®€æ˜“æ ¼å¼
content = content.replace(f"@@{agent_id}", "").strip()
return content if content else "è¯·@æˆ‘å¹¶å‘é€å…·ä½“é—®é¢˜~"
# 3. AIå›å¤å‡½æ•°ï¼ˆå¼‚å¸¸åˆ†çº§Â·è¶…æ—¶ä¼˜åŒ–ï¼‰
def get_ai_reply(message):
try:
response = ai_client.chat.completions.create(
model="qwen-turbo" if DASHSCOPE_API_KEY else "gpt-3.5-turbo",
messages=[{"role": "user", "content": message}],
temperature=0.7,
max_tokens=500,
timeout=AI_TIMEOUT
)
return response.choices[0].message.content.strip()
# ä¸´æ—¶é”™è¯¯ï¼šAIè¶…æ—¶/ç½‘ç»œé”™è¯¯ï¼ˆéœ€è¦é‡è¯•ï¼‰
except (openai.APITimeoutError, openai.APIConnectionError, requests.Timeout, requests.ConnectionError) as e:
print(f"âš ï¸ AIä¸´æ—¶é”™è¯¯ï¼ˆå¯é‡è¯•ï¼‰ï¼š{str(e)[:50]}")
raise e  # æŠ›å‡ºå¼‚å¸¸Â·è®©ä¸Šå±‚å¤„ç†é‡è¯•
# æ°¸ä¹…é”™è¯¯ï¼šå‚æ•°/å¯†é’¥/ä»£ç é”™è¯¯ï¼ˆæ— éœ€é‡è¯•ï¼‰
except Exception as e:
print(f"âŒ AIæ°¸ä¹…é”™è¯¯ï¼ˆæ— éœ€é‡è¯•ï¼‰ï¼š{str(e)[:50]}")
return "AIåŠ©ç†æš‚æ—¶ç¦»çº¿ï¼Œç¨åå†è¯•~"
# ====================== æ ¸å¿ƒå›è°ƒæ¥å£ï¼ˆåˆ†çº§å¼‚å¸¸Â·å…¨è§„èŒƒï¼‰======================
@app.route("/wework/callback", methods=["GET", "POST"])
def wework_callback():
# æå–å…¬å…±å‚æ•°
msg_signature = request.args.get("msg_signature")
timestamp = request.args.get("timestamp")
nonce = request.args.get("nonce")
# GETè¯·æ±‚ï¼šå›è°ƒURLéªŒè¯ï¼ˆå®˜æ–¹è§„èŒƒÂ·å®Œæ•´ç­¾åï¼‰
if request.method == "GET":
try:
echostr = request.args.get("echostr")
ret = crypto.verify_url(msg_signature, timestamp, nonce, echostr)
return ret
except InvalidSignatureException:
return "Invalid Signature", 403
except Exception as e:
print(f"âŒ URLéªŒè¯å¤±è´¥ï¼š{e}")
return "Invalid Signature", 403
# POSTè¯·æ±‚ï¼šæ¶ˆæ¯æ¥æ”¶ä¸å›å¤ï¼ˆåˆ†çº§å¼‚å¸¸Â·æ’é‡å®‰å…¨Â·å®˜æ–¹è§„èŒƒï¼‰
try:
# 1. è§£å¯†æ¶ˆæ¯
msg_xml = crypto.decrypt_message(request.data.decode("utf-8"), msg_signature, timestamp, nonce)
msg = wechatpy.parse_message(msg_xml)
# 2. æ¶ˆæ¯æ’é‡ï¼ˆåŒæ–¹æ¡ˆÂ·è‡ªåŠ¨åˆ‡æ¢ï¼‰
if hasattr(msg, "msg_id") and msg_dup_check(msg.msg_id):
return "success"
# 3. ä»…å¤„ç†æ–‡æœ¬æ¶ˆæ¯
if not isinstance(msg, TextMessage):
return "success"
# 4. è§£æç¾¤èŠ@Â·æå–çº¯æ–‡æœ¬
pure_content = parse_group_at_msg(msg, AGENT_ID)
# 5. è°ƒç”¨AIç”Ÿæˆå›å¤ï¼ˆæŠ›å‡ºä¸´æ—¶é”™è¯¯Â·ä¸Šå±‚å¤„ç†ï¼‰
ai_reply = get_ai_reply(pure_content)
# 6. æ„é€ å¹¶åŠ å¯†å›å¤æ¶ˆæ¯ï¼ˆå®˜æ–¹æ ¼å¼ï¼‰
reply_msg = TextMessage(
content=ai_reply,
source=msg.target,
target=msg.source,
agent_id=AGENT_ID
)
reply_xml = crypto.encrypt_message(reply_msg.render(), nonce, timestamp)
# 7. è¿”å›å“åº”
response = make_response(reply_xml)
response.headers["Content-Type"] = "application/xml; charset=utf-8"
return response
# æ•è·ä¸´æ—¶é”™è¯¯ï¼šAIè¶…æ—¶/ç½‘ç»œ/åŠ è§£å¯†ä¸´æ—¶å¼‚å¸¸Â·è¿”å›503è®©ä¼ä¸šå¾®ä¿¡é‡è¯•
except (openai.APITimeoutError, openai.APIConnectionError, requests.Timeout, requests.ConnectionError) as e:
print(f"âš ï¸ ä¸´æ—¶é”™è¯¯Â·è§¦å‘ä¼ä¸šå¾®ä¿¡é‡è¯•ï¼š{str(e)[:50]}")
return "Service Unavailable", 503
# æ•è·æ°¸ä¹…é”™è¯¯ï¼šæ‰€æœ‰å…¶ä»–å¼‚å¸¸Â·è¿”å›successé¿å…æ— é™é‡è¯•
except Exception as e:
print(f"âŒ æ°¸ä¹…é”™è¯¯Â·å¿½ç•¥é‡è¯•ï¼š{str(e)[:50]}")
return "success"
# ====================== å¯åŠ¨æœåŠ¡ï¼ˆæµ‹è¯•/ç”Ÿäº§Â·è‡ªåŠ¨é€‚é…ï¼‰======================
if __name__ == "__main__":
# å¯åŠ¨ngrokï¼ˆä»…æµ‹è¯•æ¨¡å¼Â·è‡ªåŠ¨å¯ç”¨ï¼‰
if NGROK_AUTHTOKEN:
ngrok_tunnel = ngrok.connect(5000, proto="https")
print(f"âœ… æµ‹è¯•ç”¨å…¬ç½‘åœ°å€ï¼š{ngrok_tunnel.public_url}")
print(f"âœ… æµ‹è¯•ç”¨å›è°ƒURLï¼š{ngrok_tunnel.public_url}/wework/callback")
# å¯åŠ¨å¼‚æ­¥WSGIæœåŠ¡å™¨ï¼ˆç”Ÿäº§çº§Â·æ”¯æŒå¤šworkerï¼‰
print(f"âœ… æœåŠ¡å¯åŠ¨æˆåŠŸÂ·ç›‘å¬åœ°å€ï¼š0.0.0.0:5000")
print(f"âœ… AIè¶…æ—¶ï¼š{AI_TIMEOUT}ç§’Â·æ¶ˆæ¯æ’é‡è¿‡æœŸï¼š{MSG_EXPIRE_SECONDS}ç§’")
# ç”Ÿäº§éƒ¨ç½²å¯ä¿®æ”¹workerså‚æ•°ï¼ˆå¦‚workers=4ï¼‰ï¼Œæœ¬åœ°æµ‹è¯•ç”¨1ä¸ªworker
http_server = WSGIServer(("0.0.0.0", 5000), app, workers=1 if not REDIS_CLIENT else 4)
http_server.serve_forever()
äº”ã€æ–¹æ¡ˆ2ï¼šåŸç”ŸAPIç‰ˆï¼ˆç”Ÿäº§æ¨èÂ·100%å¯æ§Â·æ— ç¬¬ä¸‰æ–¹ä¾èµ–ï¼‰
æ ¸å¿ƒä¼˜åŠ¿
- å®Œå…¨å¼ƒç”¨wechatpyï¼ŒåŸºäºä¼ä¸šå¾®ä¿¡å®˜æ–¹WXBizMsgCrypt.pyå¼€å‘ï¼Œ100%å¯æ§ï¼Œæ— ç‰ˆæœ¬å…¼å®¹é—®é¢˜ï¼›
- é›†æˆæ‰€æœ‰ç”Ÿäº§çº§ç‰¹æ€§ï¼šRedisåˆ†å¸ƒå¼æ’é‡ã€AccessTokenå…¨å±€å…±äº«ã€åˆ†çº§å¼‚å¸¸å¤„ç†ã€ç¯å¢ƒè‡ªåŠ¨éš”ç¦»ï¼›
- åŠ è§£å¯†/å›è°ƒé€»è¾‘å®Œå…¨éµå¾ªä¼ä¸šå¾®ä¿¡å®˜æ–¹è§„èŒƒï¼Œæ— ä»»ä½•è‡ªå®šä¹‰å®ç°ï¼Œå…¼å®¹æ€§å’Œç¨³å®šæ€§æ‹‰æ»¡ï¼›
- æ”¯æŒå¤šworker/å¤šè¿›ç¨‹éƒ¨ç½²ï¼Œå¯ç›´æ¥ç”¨äºä¼ä¸šç”Ÿäº§ç¯å¢ƒï¼Œæ— éœ€é¢å¤–æ”¹é€ ã€‚
å…³é”®è¯´æ˜
- æ ¸å¿ƒé€»è¾‘ä¸wechatpyç‰ˆä¸€è‡´ï¼Œå·®å¼‚ä»…åœ¨
ä¼ä¸šå¾®ä¿¡åŠ è§£å¯†/æ¶ˆæ¯è§£æ
éƒ¨åˆ†ï¼Œä½¿ç”¨å®˜æ–¹åº“æ›¿ä»£wechatpyå°è£…ï¼›
- æ‰€æœ‰å·¥å…·å‡½æ•°ï¼ˆæ’é‡/AIè°ƒç”¨/Tokenç¼“å­˜ï¼‰ä¸wechatpyç‰ˆå®Œå…¨é€šç”¨ï¼Œæµ‹è¯•/ç”Ÿäº§åˆ‡æ¢é€»è¾‘ä¸€è‡´ï¼›
- æ¨è
ç”Ÿäº§ç¯å¢ƒä¼˜å…ˆä½¿ç”¨æœ¬æ–¹æ¡ˆ
ï¼Œé¿å…ç¬¬ä¸‰æ–¹åº“ç‰ˆæœ¬å·®å¼‚å¸¦æ¥çš„æ½œåœ¨é—®é¢˜ã€‚
# 2026ä¼ä¸šå¾®ä¿¡+AI åŸç”ŸAPIç»ˆæç”Ÿäº§ç‰ˆï¼ˆ100%å®˜æ–¹è§„èŒƒÂ·æ— ç¬¬ä¸‰æ–¹ä¾èµ–Â·åˆ†å¸ƒå¼éƒ¨ç½²ï¼‰
from flask import Flask, request, make_response
import requests
import os
import re
import time
import threading
import string
import random
from dotenv import load_dotenv
from pyngrok import conf, ngrok
from gevent.pywsgi import WSGIServer
from gevent import monkey
from openai import OpenAI
import redis
from functools import wraps
# å¯¼å…¥ä¼ä¸šå¾®ä¿¡å®˜æ–¹åŠ è§£å¯†åº“ï¼ˆå¿…é¡»æ”¾åœ¨åŒçº§ç›®å½•Â·åŸç‰ˆæ— ä¿®æ”¹ï¼‰
from WXBizMsgCrypt import WXBizMsgCrypt
# 1. å¼€å¯geventçŒ´å­è¡¥ä¸Â·å¼‚æ­¥å¤„ç†Â·å½»åº•è§£å†³5ç§’è¶…æ—¶
monkey.patch_all()
# 2. åŠ è½½ç¯å¢ƒå˜é‡Â·æµ‹è¯•/ç”Ÿäº§å®Œå…¨éš”ç¦»
load_dotenv()
# 3. åˆå§‹åŒ–Rediså®¢æˆ·ç«¯ï¼ˆç”Ÿäº§æ¨¡å¼Â·æœ¬åœ°æµ‹è¯•è‡ªåŠ¨é™çº§ï¼‰
REDIS_CLIENT = None
if os.getenv("REDIS_HOST") and os.getenv("REDIS_PORT"):
REDIS_CLIENT = redis.Redis(
host=os.getenv("REDIS_HOST"),
port=int(os.getenv("REDIS_PORT", 6379)),
password=os.getenv("REDIS_PASSWORD", ""),
db=int(os.getenv("REDIS_DB", 0)),
decode_responses=True,
socket_timeout=2
)
try:
REDIS_CLIENT.ping()
print(f"âœ… Redisè¿æ¥æˆåŠŸÂ·ç”Ÿäº§æ¨¡å¼å·²å¯ç”¨ï¼ˆåˆ†å¸ƒå¼æ’é‡+Tokenå…±äº«ï¼‰")
except Exception as e:
REDIS_CLIENT = None
print(f"âš ï¸ Redisè¿æ¥å¤±è´¥Â·é™çº§ä¸ºæœ¬åœ°æµ‹è¯•æ¨¡å¼Â·{str(e)[:30]}")
# 4. æœ¬åœ°æ¶ˆæ¯æ’é‡Â·çº¿ç¨‹å®‰å…¨ï¼ˆå­—å…¸+äº’æ–¥é”ï¼‰
LOCAL_PROCESSED_MSGS = {}
MSG_LOCK = threading.Lock()
# 5. å®šæ—¶æ¸…ç†çº¿ç¨‹ï¼ˆåå°å®ˆæŠ¤Â·è‡ªåŠ¨æ¸…ç†è¿‡æœŸæ¶ˆæ¯ï¼‰
def clean_expired_msgs():
expire_seconds = int(os.getenv("MSG_EXPIRE_SECONDS", 60))
while True:
now = time.time()
# æœ¬åœ°å­—å…¸æ¸…ç†Â·çº¿ç¨‹å®‰å…¨
with MSG_LOCK:
for msg_id in list(LOCAL_PROCESSED_MSGS.keys()):
if now - LOCAL_PROCESSED_MSGS[msg_id] > expire_seconds:
del LOCAL_PROCESSED_MSGS[msg_id]
time.sleep(expire_seconds)
threading.Thread(target=clean_expired_msgs, daemon=True).start()
# ====================== å·¥å…·è£…é¥°å™¨Â·çº¿ç¨‹å®‰å…¨ ======================
def thread_safe(func):
@wraps(func)
def wrapper(*args, **kwargs):
with MSG_LOCK:
return func(*args, **kwargs)
return wrapper
# ====================== ç¯å¢ƒå˜é‡è¯»å–+å…¨å±€ä¸¥æ ¼æ ¡éªŒ ======================
# ä¼ä¸šå¾®ä¿¡æ ¸å¿ƒå‚æ•°
CORP_ID = os.getenv("CORP_ID")
AGENT_ID = int(os.getenv("AGENT_ID", 0))
APP_SECRET = os.getenv("APP_SECRET")
TOKEN = os.getenv("TOKEN")
ENCODING_AES_KEY = os.getenv("ENCODING_AES_KEY")
# AIå‚æ•°
DASHSCOPE_API_KEY = os.getenv("DASHSCOPE_API_KEY")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENAI_API_BASE = os.getenv("OPENAI_API_BASE")
AI_TIMEOUT = float(os.getenv("AI_TIMEOUT", 4.5))
# ç¼“å­˜/è¶…æ—¶é…ç½®
MSG_EXPIRE_SECONDS = int(os.getenv("MSG_EXPIRE_SECONDS", 60))
TOKEN_EXPIRE_SECONDS = int(os.getenv("TOKEN_EXPIRE_SECONDS", 7000))
# ç¯å¢ƒæ¨¡å¼å¼€å…³Â·è‡ªåŠ¨éš”ç¦»
NGROK_AUTHTOKEN = os.getenv("NGROK_AUTHTOKEN")
# å…¨å±€éç©ºæ ¡éªŒÂ·æå‰æš´éœ²é…ç½®é”™è¯¯Â·é¿å…è¿è¡Œæ—¶å¼‚å¸¸
assert CORP_ID, "âŒ ç¯å¢ƒå˜é‡CORP_IDä¸èƒ½ä¸ºç©ºï¼"
assert AGENT_ID > 0, "âŒ ç¯å¢ƒå˜é‡AGENT_IDå¿…é¡»ä¸ºæ­£æ•´æ•°ï¼"
assert APP_SECRET, "âŒ ç¯å¢ƒå˜é‡APP_SECRETï¼ˆcorpsecretï¼‰ä¸èƒ½ä¸ºç©ºï¼"
assert TOKEN, "âŒ ç¯å¢ƒå˜é‡TOKENä¸èƒ½ä¸ºç©ºï¼"
assert len(ENCODING_AES_KEY) == 43, "âŒ ENCODING_AES_KEYå¿…é¡»ä¸º43ä½å­—ç¬¦ä¸²ï¼"
assert DASHSCOPE_API_KEY or OPENAI_API_KEY, "âŒ å¿…é¡»é…ç½®é€šä¹‰åƒé—®/OpenAI API_KEYï¼"
assert 0 < AI_TIMEOUT <= 5, "âŒ AI_TIMEOUTå¿…é¡»åœ¨0-5ç§’ä¹‹é—´ï¼ˆæ¨è4.5ï¼‰ï¼"
# ====================== åˆå§‹åŒ–é…ç½®ï¼ˆå…¨è‡ªåŠ¨åŒ–Â·æ— äººå·¥å¹²é¢„ï¼‰======================
# 1. ngrokåˆå§‹åŒ–ï¼ˆæµ‹è¯•æ¨¡å¼è‡ªåŠ¨å¯ç”¨Â·ç”Ÿäº§è‡ªåŠ¨ç¦ç”¨ï¼‰
if NGROK_AUTHTOKEN:
conf.get_default().auth_token = NGROK_AUTHTOKEN
print(f"âš ï¸  å½“å‰ä¸ºã€æœ¬åœ°æµ‹è¯•æ¨¡å¼ã€‘Â·ngrokå·²å¯ç”¨")
else:
print(f"âœ… å½“å‰ä¸ºã€ç”Ÿäº§æ¨¡å¼ã€‘Â·ngrokå·²ç¦ç”¨")
# 2. Flaskåº”ç”¨åˆå§‹åŒ–
app = Flask(__name__)
app.config["JSON_AS_ASCII"] = False
# 3. ä¼ä¸šå¾®ä¿¡å®˜æ–¹åŠ è§£å¯†åº“åˆå§‹åŒ–ï¼ˆreceive_id=CORP_IDÂ·å®˜æ–¹è§„èŒƒï¼‰
wx_crypt = WXBizMsgCrypt(TOKEN, ENCODING_AES_KEY, CORP_ID)
print(f"âœ… ä¼ä¸šå¾®ä¿¡å®˜æ–¹åŠ è§£å¯†åº“åˆå§‹åŒ–å®ŒæˆÂ·receive_id=CORP_ID")
# 4. AIå®¢æˆ·ç«¯åˆå§‹åŒ–ï¼ˆé€šä¹‰åƒé—®/OpenAIÂ·å®˜æ–¹æ ‡å‡†é…ç½®Â·å·²ä¿®æ­£base_urlï¼‰
ai_client = None
if DASHSCOPE_API_KEY:
ai_client = OpenAI(
api_key=DASHSCOPE_API_KEY,
base_url="https://dashscope.aliyuncs.com/compatible-mode/v1",  # å®˜æ–¹æ ‡å‡†åœ°å€
timeout=AI_TIMEOUT
)
print(f"âœ… é€šä¹‰åƒé—®AIå®¢æˆ·ç«¯åˆå§‹åŒ–å®ŒæˆÂ·è¶…æ—¶{AI_TIMEOUT}ç§’")
elif OPENAI_API_KEY:
ai_client = OpenAI(
api_key=OPENAI_API_KEY,
base_url=OPENAI_API_BASE,
timeout=AI_TIMEOUT
)
print(f"âœ… OpenAI AIå®¢æˆ·ç«¯åˆå§‹åŒ–å®ŒæˆÂ·è¶…æ—¶{AI_TIMEOUT}ç§’")
# ====================== æ ¸å¿ƒå·¥å…·å‡½æ•°ï¼ˆç”Ÿäº§çº§Â·åŒæ–¹æ¡ˆÂ·è‡ªåŠ¨åˆ‡æ¢ï¼‰======================
# 1. AccessTokenè·å–Â·æ”¯æŒRediså…¨å±€ç¼“å­˜ï¼ˆå¤šè¿›ç¨‹/å¤šworkerå…±äº«ï¼‰
def get_access_token():
# ç”Ÿäº§æ¨¡å¼ï¼šRedisç¼“å­˜Â·å…¨å±€å…±äº«
if REDIS_CLIENT:
token_key = f"wework:token:{CORP_ID}:{AGENT_ID}"
if REDIS_CLIENT.exists(token_key):
return REDIS_CLIENT.get(token_key)
# æœ¬åœ°æ¨¡å¼/ç¼“å­˜å¤±æ•ˆï¼šè°ƒç”¨å®˜æ–¹æ¥å£è·å–
url = f"https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid={CORP_ID}&corpsecret={APP_SECRET}"
try:
res = requests.get(url, timeout=5).json()
if res.get("errcode") != 0:
raise Exception(f"é”™è¯¯ç ï¼š{res.get('errcode')}Â·é”™è¯¯ä¿¡æ¯ï¼š{res.get('errmsg')}")
token = res.get("access_token")
# ç”Ÿäº§æ¨¡å¼ï¼šç¼“å­˜tokenè‡³Redis
if REDIS_CLIENT:
REDIS_CLIENT.setex(token_key, TOKEN_EXPIRE_SECONDS, token)
print(f"âœ… AccessTokenåˆ·æ–°æˆåŠŸÂ·å·²ç¼“å­˜è‡³RedisÂ·è¿‡æœŸæ—¶é—´{TOKEN_EXPIRE_SECONDS}ç§’")
return token
except Exception as e:
print(f"âŒ AccessTokenè·å–å¤±è´¥ï¼š{e}")
raise e
# 2. æ¶ˆæ¯æ’é‡å‡½æ•°ï¼ˆRedisåˆ†å¸ƒå¼/æœ¬åœ°å­—å…¸Â·è‡ªåŠ¨åˆ‡æ¢Â·çº¿ç¨‹/è¿›ç¨‹å®‰å…¨ï¼‰
def msg_dup_check(msg_id):
if not msg_id:
return False
# ç”Ÿäº§æ¨¡å¼ï¼šRedisåˆ†å¸ƒå¼æ’é‡Â·è¿›ç¨‹å®‰å…¨
if REDIS_CLIENT:
redis_key = f"wework:msg:{msg_id}"
if REDIS_CLIENT.exists(redis_key):
return True
REDIS_CLIENT.setex(redis_key, MSG_EXPIRE_SECONDS, "1")
return False
# æµ‹è¯•æ¨¡å¼ï¼šæœ¬åœ°å­—å…¸Â·çº¿ç¨‹å®‰å…¨
@thread_safe
def local_check():
if msg_id in LOCAL_PROCESSED_MSGS:
return True
LOCAL_PROCESSED_MSGS[msg_id] = time.time()
return False
return local_check()
# 3. ç¾¤èŠ@è§£æï¼ˆå…¼å®¹æ‰€æœ‰å®˜æ–¹æ ¼å¼Â·å®æµ‹100%è¦†ç›–ï¼‰
def parse_group_at_msg(content, agent_id):
# ç§»é™¤<@userid>ä»»æ„å†…å®¹å¤æ‚æ ¼å¼
content = re.sub(r"<@[0-9a-zA-Z]+?>.*?", "", content)
# ç§»é™¤@@AGENT_IDç®€æ˜“æ ¼å¼
content = content.replace(f"@@{agent_id}", "").strip()
# ç©ºå†…å®¹å…œåº•
return content if content else "è¯·@æˆ‘å¹¶å‘é€å…·ä½“çš„é—®é¢˜å“¦~"
# 4. AIå›å¤å‡½æ•°ï¼ˆå¼‚å¸¸åˆ†çº§Â·ä¸´æ—¶é”™è¯¯æŠ›å‡ºÂ·æ°¸ä¹…é”™è¯¯å…œåº•ï¼‰
def get_ai_reply(message):
try:
# é€šä¹‰åƒé—®/OpenAIé€šç”¨è°ƒç”¨Â·æ¨¡å‹è‡ªåŠ¨é€‚é…
model = "qwen-turbo" if DASHSCOPE_API_KEY else "gpt-3.5-turbo"
response = ai_client.chat.completions.create(
model=model,
messages=[{"role": "user", "content": message}],
temperature=0.7,
max_tokens=500,
timeout=AI_TIMEOUT
)
return response.choices[0].message.content.strip()
# ä¸´æ—¶é”™è¯¯ï¼šAIè¶…æ—¶/ç½‘ç»œè¿æ¥é”™è¯¯Â·æŠ›å‡ºå¼‚å¸¸è®©ä¸Šå±‚å¤„ç†é‡è¯•
except (openai.APITimeoutError, openai.APIConnectionError, requests.Timeout, requests.ConnectionError) as e:
print(f"âš ï¸ AIä¸´æ—¶é”™è¯¯ï¼ˆå¯é‡è¯•ï¼‰ï¼š{str(e)[:50]}")
raise e
# æ°¸ä¹…é”™è¯¯ï¼šå¯†é’¥/å‚æ•°/ä»£ç é”™è¯¯Â·å…œåº•è¿”å›æç¤ºè¯­Â·æ— éœ€é‡è¯•
except Exception as e:
print(f"âŒ AIæ°¸ä¹…é”™è¯¯ï¼ˆæ— éœ€é‡è¯•ï¼‰ï¼š{str(e)[:50]}")
return "AIåŠ©ç†æš‚æ—¶ç¦»çº¿ï¼Œç¨åå†è¯•~"
# ====================== æ ¸å¿ƒå›è°ƒæ¥å£ï¼ˆ100%å®˜æ–¹è§„èŒƒÂ·åˆ†çº§å¼‚å¸¸ï¼‰======================
@app.route("/wework/callback", methods=["GET", "POST"])
def wework_callback():
# æå–ä¼ä¸šå¾®ä¿¡å¿…ä¼ å…¬å…±å‚æ•°
msg_signature = request.args.get("msg_signature", "")
timestamp = request.args.get("timestamp", str(int(time.time())))
nonce = request.args.get("nonce", "".join(random.choices(string.digits, k=8)))
# ====================== GETè¯·æ±‚ï¼šå›è°ƒURLéªŒè¯ï¼ˆå®˜æ–¹è§„èŒƒÂ·å®Œæ•´ç­¾åï¼‰======================
if request.method == "GET":
echostr = request.args.get("echostr", "")
try:
ret, reply_echostr = wx_crypt.VerifyURL(msg_signature, timestamp, nonce, echostr)
if ret == 0:
return reply_echostr
else:
print(f"âŒ URLéªŒè¯å¤±è´¥Â·å®˜æ–¹é”™è¯¯ç ï¼š{ret}")
return "Invalid Signature", 403
except Exception as e:
print(f"âŒ URLéªŒè¯å¼‚å¸¸ï¼š{e}")
return "Invalid Signature", 403
# ====================== POSTè¯·æ±‚ï¼šæ¶ˆæ¯æ¥æ”¶ä¸å›å¤ï¼ˆå…¨æµç¨‹é—­ç¯ï¼‰======================
try:
# 1. è¯»å–åŠ å¯†è¯·æ±‚ä½“
req_data = request.data.decode("utf-8")
# 2. å®˜æ–¹åº“è§£å¯†æ¶ˆæ¯ï¼ˆéªŒç­¾+è§£å¯†Â·100%ç¬¦åˆè§„èŒƒï¼‰
ret, decrypted_xml = wx_crypt.DecryptMsg(req_data, msg_signature, timestamp, nonce)
if ret != 0:
raise Exception(f"æ¶ˆæ¯è§£å¯†å¤±è´¥Â·å®˜æ–¹é”™è¯¯ç ï¼š{ret}")
# 3. è§£æXMLæ¶ˆæ¯Â·æå–æ ¸å¿ƒå­—æ®µ
import xml.etree.ElementTree as ET
root = ET.fromstring(decrypted_xml)
msg_id = root.findtext("MsgId", "")
msg_type = root.findtext("MsgType", "")
content = root.findtext("Content", "")
from_user = root.findtext("FromUserName", "")
to_user = root.findtext("ToUserName", "")
chat_type = root.findtext("ChatType", "")
is_group = True if chat_type else False
# 4. æ¶ˆæ¯æ’é‡Â·é¿å…é‡å¤å›å¤ï¼ˆåŒæ–¹æ¡ˆÂ·è‡ªåŠ¨åˆ‡æ¢ï¼‰
if msg_dup_check(msg_id):
return "success"
# 5. ä»…å¤„ç†æ–‡æœ¬æ¶ˆæ¯Â·å…¶ä»–ç±»å‹ç›´æ¥è¿”å›
if msg_type != "text":
return "success"
# 6. è§£æç¾¤èŠ@Â·æå–çº¯æ–‡æœ¬å†…å®¹
pure_content = parse_group_at_msg(content, AGENT_ID) if is_group else content.strip()
# 7. è°ƒç”¨AIç”Ÿæˆå›å¤Â·ä¸´æ—¶é”™è¯¯æŠ›å‡ºÂ·æ°¸ä¹…é”™è¯¯å…œåº•
ai_reply = get_ai_reply(pure_content)
# 8. æ„é€ æ˜æ–‡å›å¤XMLÂ·ä¸¥æ ¼éµå¾ªä¼ä¸šå¾®ä¿¡å®˜æ–¹æ ¼å¼
reply_xml = f""""""
# 9. å®˜æ–¹åº“åŠ å¯†å›å¤Â·ç”Ÿæˆå¸¦Encryptæ ‡ç­¾çš„æœ€ç»ˆXML
ret, encrypted_reply = wx_crypt.EncryptMsg(reply_xml, nonce, timestamp)
if ret != 0:
raise Exception(f"æ¶ˆæ¯åŠ å¯†å¤±è´¥Â·å®˜æ–¹é”™è¯¯ç ï¼š{ret}")
# 10. è¿”å›åŠ å¯†å“åº”Â·è®¾ç½®æ­£ç¡®Content-Type
response = make_response(encrypted_reply)
response.headers["Content-Type"] = "application/xml; charset=utf-8"
return response
# æ•è·ä¸´æ—¶é”™è¯¯ï¼šè¶…æ—¶/ç½‘ç»œ/åŠ è§£å¯†ä¸´æ—¶å¼‚å¸¸Â·è¿”å›503è®©ä¼ä¸šå¾®ä¿¡é‡è¯•ï¼ˆæœ€å¤š3æ¬¡ï¼‰
except (openai.APITimeoutError, openai.APIConnectionError, requests.Timeout, requests.ConnectionError) as e:
print(f"âš ï¸ ä¸´æ—¶é”™è¯¯Â·è§¦å‘ä¼ä¸šå¾®ä¿¡é‡è¯•ï¼š{str(e)[:50]}")
return "Service Unavailable", 503
# æ•è·æ°¸ä¹…é”™è¯¯ï¼šæ‰€æœ‰å…¶ä»–å¼‚å¸¸Â·è¿”å›successé¿å…æ— é™é‡è¯•Â·è®°å½•æ—¥å¿—ä¾¿äºæ’æŸ¥
except Exception as e:
print(f"âŒ æ°¸ä¹…é”™è¯¯Â·å¿½ç•¥é‡è¯•ï¼š{str(e)[:50]}")
return "success"
# ====================== å¯åŠ¨æœåŠ¡ï¼ˆç”Ÿäº§çº§Â·è‡ªåŠ¨é€‚é…æµ‹è¯•/ç”Ÿäº§ï¼‰======================
if __name__ == "__main__":
# å¯åŠ¨ngrokï¼ˆä»…æµ‹è¯•æ¨¡å¼Â·è‡ªåŠ¨å¯ç”¨ï¼‰
if NGROK_AUTHTOKEN:
ngrok_tunnel = ngrok.connect(5000, proto="https")
print(f"âœ… æµ‹è¯•ç”¨å…¬ç½‘HTTPSåœ°å€ï¼š{ngrok_tunnel.public_url}")
print(f"âœ… æµ‹è¯•ç”¨å›è°ƒURLï¼š{ngrok_tunnel.public_url}/wework/callback")
# å¯åŠ¨å¼‚æ­¥WSGIæœåŠ¡å™¨Â·æ”¯æŒå¤šworkerï¼ˆç”Ÿäº§4ä¸ªÂ·æµ‹è¯•1ä¸ªï¼‰
worker_num = 4 if REDIS_CLIENT else 1
print(f"âœ… æœåŠ¡æˆåŠŸå¯åŠ¨Â·ç›‘å¬åœ°å€ï¼š0.0.0.0:5000Â·å·¥ä½œè¿›ç¨‹æ•°ï¼š{worker_num}")
print(f"âœ… æ ¸å¿ƒé…ç½®ï¼šAIè¶…æ—¶{AI_TIMEOUT}ç§’Â·æ¶ˆæ¯æ’é‡è¿‡æœŸ{MSG_EXPIRE_SECONDS}ç§’")
http_server = WSGIServer(("0.0.0.0", 5000), app, workers=worker_num)
http_server.serve_forever()
å…­ã€å…³é”®ä½¿ç”¨æŒ‡å—ï¼ˆæµ‹è¯•/ç”Ÿäº§Â·åˆ†æ­¥æ“ä½œÂ·æ— å‘ï¼‰
ğŸ§ª æœ¬åœ°æµ‹è¯•æ¨¡å¼ï¼ˆä¸ªäººå¼€å‘Â·å¿«é€ŸéªŒè¯ï¼‰
1. å‡†å¤‡å·¥ä½œï¼šå®‰è£…é€šç”¨ä¾èµ–ã€æ”¾ç½®å®˜æ–¹
WXBizMsgCrypt.py
ã€æ–°å»º
.env
æ–‡ä»¶ï¼›
2. .envé…ç½®ï¼šå¡«å†™
å…¨å±€æ ¸å¿ƒå‚æ•°
+
NGROK_AUTHTOKEN
ï¼Œç•™ç©ºRedisé…ç½®ï¼›
3. å¯åŠ¨Redisï¼šæ— éœ€å¯åŠ¨ï¼ˆä»£ç è‡ªåŠ¨é™çº§ä¸ºæœ¬åœ°å­—å…¸æ’é‡ï¼‰ï¼›
4. è¿è¡Œä»£ç ï¼šç›´æ¥æ‰§è¡ŒPythonæ–‡ä»¶ï¼Œå¤åˆ¶ngrokç”Ÿæˆçš„å›è°ƒURLé…ç½®åˆ°ä¼ä¸šå¾®ä¿¡åå°ï¼›
5. æµ‹è¯•ï¼šä¼ä¸šå¾®ä¿¡å‘æ¶ˆæ¯/ç¾¤èŠ@ï¼Œå³å¯æ”¶åˆ°AIå›å¤ï¼Œæ— é‡å¤ã€æ— è¶…æ—¶ã€‚
ğŸš€ ç”Ÿäº§éƒ¨ç½²æ¨¡å¼ï¼ˆä¼ä¸šä½¿ç”¨Â·ç¨³å®šè¿è¡Œï¼‰
1. æœåŠ¡å™¨å‡†å¤‡ï¼šäº‘æœåŠ¡å™¨ï¼ˆ2æ ¸4Gå³å¯ï¼‰ã€å›ºå®šåŸŸåï¼ˆICPå¤‡æ¡ˆï¼‰ã€HTTPSè¯ä¹¦ï¼ˆLet's Encryptå…è´¹ï¼‰ï¼›
2. ç¯å¢ƒå‡†å¤‡ï¼šå®‰è£…é€šç”¨ä¾èµ–ã€éƒ¨ç½²RedisæœåŠ¡ï¼ˆå•èŠ‚ç‚¹ï¼‰ã€æ”¾ç½®å®˜æ–¹
WXBizMsgCrypt.py
ï¼›
3. .envé…ç½®ï¼šå¡«å†™
å…¨å±€æ ¸å¿ƒå‚æ•°
ï¼Œç•™ç©ºNGROK_AUTHTOKENï¼Œå¡«å†™Redisé…ç½®ï¼›
4. è¿›ç¨‹ç®¡ç†ï¼šä½¿ç”¨Gunicornå¯åŠ¨æœåŠ¡ï¼ˆæ›¿ä»£ä»£ç å†…ç½®WSGIï¼‰ï¼Œç¤ºä¾‹å‘½ä»¤ï¼š
gunicorn -w 4 -b 0.0.0.0:5000 app:app -k gevent
-
-w 4
ï¼š4ä¸ªå·¥ä½œè¿›ç¨‹ï¼Œæ ¹æ®æœåŠ¡å™¨é…ç½®è°ƒæ•´ï¼›
-
-k gevent
ï¼šå¼‚æ­¥å·¥ä½œæ¨¡å¼ï¼Œé€‚é…ä¼ä¸šå¾®ä¿¡5ç§’è¶…æ—¶ï¼›
5. å®ˆæŠ¤è¿›ç¨‹ï¼šä½¿ç”¨Supervisoré…ç½®æœåŠ¡å®ˆæŠ¤ï¼Œé¿å…è¿›ç¨‹æ„å¤–é€€å‡ºï¼›
6. ç›‘æ§ï¼šæ·»åŠ æœåŠ¡å™¨/Redis/AIæ¥å£ç›‘æ§ï¼ŒåŠæ—¶å‘ç°å¼‚å¸¸ã€‚